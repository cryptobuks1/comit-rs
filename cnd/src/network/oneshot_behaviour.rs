use crate::network::oneshot_protocol;
use libp2p::{
    core::{ConnectedPoint, Multiaddr, PeerId},
    swarm::{
        NetworkBehaviour, NetworkBehaviourAction, OneShotHandler, PollParameters, ProtocolsHandler,
    },
};
use serde::{de::DeserializeOwned, Serialize};
use std::{
    collections::VecDeque,
    fmt::Debug,
    task::{Context, Poll},
};
use tracing::trace;

/// Generic network behaviour for handling oneshot protocols.
#[derive(Debug)]
pub struct Behaviour<M> {
    /// Events that need to be yielded to the outside when polling.
    events: VecDeque<NetworkBehaviourAction<oneshot_protocol::OutboundConfig<M>, OutEvent<M>>>,
}

impl<M> Default for Behaviour<M> {
    fn default() -> Self {
        Behaviour {
            events: VecDeque::new(),
        }
    }
}

/// Event generated by the NetworkBehaviour and that the swarm will report back.
#[derive(Clone, Copy, Debug)]
pub enum OutEvent<M> {
    /// Emitted once we receive a message from the other peer.
    Received(M),
    /// Emitted once we successfully sent a message to the other peer.
    Sent,
}

impl<M> From<M> for OutEvent<M>
where
    M: oneshot_protocol::Message,
{
    fn from(msg: M) -> Self {
        OutEvent::Received(msg)
    }
}

impl<M> From<()> for OutEvent<M> {
    fn from(_: ()) -> Self {
        OutEvent::Sent
    }
}

impl<M> NetworkBehaviour for Behaviour<M>
where
    M: oneshot_protocol::Message + Serialize + DeserializeOwned + Clone + Debug + Send + 'static,
{
    type ProtocolsHandler = OneShotHandler<
        oneshot_protocol::InboundConfig<M>,
        oneshot_protocol::OutboundConfig<M>,
        OutEvent<M>,
    >;
    type OutEvent = OutEvent<M>;

    fn new_handler(&mut self) -> Self::ProtocolsHandler {
        Default::default()
    }

    fn addresses_of_peer(&mut self, _: &PeerId) -> Vec<Multiaddr> {
        Vec::new() // Announce protocol takes care of this.
    }

    fn inject_connected(&mut self, _: PeerId, _: ConnectedPoint) {
        // Do nothing, announce protocol is going to take care of connections.
    }

    fn inject_disconnected(&mut self, _: &PeerId, _: ConnectedPoint) {
        // Do nothing, announce protocol is going to take care of connections.
    }

    fn inject_node_event(&mut self, peer_id: PeerId, event: OutEvent<M>) {
        match event {
            OutEvent::Received(message) => {
                trace!(
                    "Received message from {} on protocol {}: {:?}",
                    peer_id,
                    M::INFO,
                    message
                );

                // Add the message to be dispatched to the user.
                self.events
                    .push_back(NetworkBehaviourAction::GenerateEvent(OutEvent::Received(
                        message,
                    )));
            }
            OutEvent::Sent => trace!("Sent message to {} on protocol {}", peer_id, M::INFO),
        }
    }

    fn poll(
        &mut self,
        _: &mut Context<'_>,
        _: &mut impl PollParameters,
    ) -> Poll<
        NetworkBehaviourAction<
            <Self::ProtocolsHandler as ProtocolsHandler>::InEvent,
            Self::OutEvent,
        >,
    > {
        if let Some(event) = self.events.pop_front() {
            return Poll::Ready(event);
        }

        Poll::Pending
    }
}
